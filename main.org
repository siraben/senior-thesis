#+TITLE: Formalizing graph theory in type theory
#+AUTHOR: Siraphob (Ben) Phipathananunth
#+OPTIONS: toc:nil
#+LATEX_CLASS: scrartcl
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage{bussproofs}
#+LATEX_HEADER: \usepackage{amsthm}
#+LATEX_HEADER: \usepackage{coqdoc}
#+LATEX_HEADER: \usepackage{algpseudocode,algorithm,algorithmicx}
#+LATEX_HEADER: \newtheorem*{thm*}{Theorem}
#+LATEX_HEADER: \newtheorem{thm}{Theorem}
#+LATEX_HEADER: \newtheorem*{lem}{Lemma}
#+LATEX_HEADER: \usepackage[backend=biber]{biblatex}
#+LATEX_HEADER: \addbibresource{citations.bib}

\newcommand{\typ}{\,:\,}
\newcommand{\lam}[2]{\lambda #1.\,#2}
\newcommand{\app}[2]{#1\,#2}
\newcommand{\red}{\to_\beta}
\newcommand{\tred}{\twoheadrightarrow_\beta}

#+BEGIN_abstract
Despite the rich theory and extensive applications of graph theory in
computer science and mathematics, formal developments of graph theory
have mostly been restricted to specific applications or definitions of
graphs. In this work we seek to catalog various approaches to
formalization of graph theory that have been taken in the literature,
in particular, the motivations underlying the formalization, the
theoretical design choices taken and the strength of the
conclusions. We also present a our own novel formal theory of graphs
to prove correctness of Wigderson's graph coloring algorithm.
#+END_abstract

#+BEGIN_comment
Notes for presentation later:
- interesting thing is that this work involves simultaneously ideas
  from logic, type theory, graph theory and computer science
#+END_comment

#+BEGIN_comment
• Introduction
  • Historical context for logics, formalization of mathematics
• Overview of dependent type theory
  • Comparisons with set theory and first-order theories
  • Curry-Howard correspondence
  • Constructivism and axioms
  • Representation of mathematical objects in type theory
• Overview of graph theory formalizations in Coq
  • math-comp (2008), formalization of four-color theorem
  • CertiGraph (2019), verification of graph-manipulating programs
  • Doczkal and Pous (2019), formalization of Menger’s theorem and treewidths
  • my formalization, verification of graph coloring
• Conclusion
  • Relation to developments in other proof assistants (Lean, Isabelle/HOL)
• Future work
#+END_comment

#+BEGIN_comment
Writing notes:
- do not write too much about type theory since we really want to get
  to writing about *how to define graph theory in type theory*, compare
  the different formalizations, organizing the theories and proof
  engineering
- can always refer reader to other sources (make sure to cite)
#+END_comment
\tableofcontents
\newpage
* Introduction
The formalist approach to mathematics has had a long history dating
back to Euclid's /Elements/. In such developments, it is desirable to
capture arguments and conclusions drawn from a finite set of axioms
and rules of inference. Proof checking would then be a process that a
mathematician could follow by hand. If the axioms and inferences were
applied correctly, then that is all that is needed to establish the
validity of a result.

However, in recent years, there have been cases where some
mathematical proofs were considered infeasible for a human to verify,
thus bringing into question the validity of the result. For instance,
in 1976, Appel and Haken announced a proof of the four-color problem
which was assisted in part by a computer program to perform the
extensive case analysis for the reducible configurations. However, in
the years that followed, several errors were uncovered which were
subsequently fixed. Eventually, in 2005, Gonthier et al. formalized
the result in the Coq proof assistant, eliminating the need for
trusting a program to check the cases.\cite{gonthier}

A similar series of events played out for the proof of the Kepler
Conjecture, which concerns the optimal packing density for spheres in
three dimensions. Hales announced a proof of the Kepler conjecture
involving lengthy case analysis with computer
assistance. Subsequently, with Hales leading the Flyspeck project, a
formal proof of the Kepler conjecture was announced in 2017, using the
Isabelle and HOL Light proof assistants.\cite{hales}

Mechanization can also provide much-needed rigor to areas that contain
many folklore results. In 2021, Forster et al. presented a mechanized
proof of the time invariance thesis for the weak call-by-value
\lambda-calculus, which states that the weak call-by-value
\lambda-calculus and Turing machines can simulate each other with a
polynomial overhead in time.\cite{forster} They provide an account of
prior work on the result and the varying levels of formality in
them. The work has been contributed to the Coq Library of
Undecidability Proofs.

Inspired by these lines of work, we seek to understand, document and
develop mechanized theories of graph theory in Coq. Graph theory is a
particularly suitable area for mechanization due to its wide
applicability across various fields, its simple underlying structure,
and its computability. Graphs are fundamental objects in mathematics
and computer science, with numerous applications in physics, biology,
social sciences, and engineering. They are used to model complex
systems, such as networks of social interactions, transportation
systems, communication networks, and more.

The simplicity of a graph's underlying structure makes them a natural
fit for mechanization. Graphs consist of vertices and edges, which can
be represented as sets, functions or relations (as we shall see,
representation can bring have subtle metatheoretic implications). This
simplicity allows for a clear formalization of the concepts and
definitions of graph theory, and facilitates the automation of
reasoning tasks.

Furthermore, graph algorithms are inherently computable, making them
amenable to computer-assisted proofs. The algorithms for problems such
as finding the shortest path between two vertices, testing for the
existence of a cycle, or determining the chromatic number of a graph,
can be implemented in a computer program and executed to obtain a
solution. This computability enables the use of proof assistants,
which can help verify the correctness of the algorithms and proofs.

* Overview of dependent type theory
Type theory has a rich history, dating back to the work of Bertrand
Russell and Alfred North Whitehead's Principia Mathematica in the
early 20^{th} century.\cite{whitehead} The aim of type theory is to
provide a foundation for mathematics that avoids the paradoxes arising
from naive set theory. In type theory, the objects of interest are not
sets, but rather types and terms over those types.

Simply Typed Lambda Calculus (STLC) is a type theory that was
introduced by Church in the 1940s. It consists of rules of inference
that declare how one may produce valid derivations. The objects of
interest in STLC are terms and types over those terms. When a term $x$
has the type $\tau$, the notational convention is $x:\tau$, which is
analogous to set membership.

The terms are built up from variables, constants, and functions,
according to the following grammar:

\begin{align*}
\textit{Term} \ e & ::= x \mid \lambda x : \tau . e \mid e_1 \ e_2 \\
\textit{Type} \ \tau & ::= \alpha \mid \tau_1 \to \tau_2
\end{align*}

Proof rules are a useful tool in STLC to establish the validity of
type derivations. Here are the inference rules for the three rules in
STLC, along with their names:

\begin{prooftree}
\AxiomC{}
\RightLabel{(Var)}
\UnaryInfC{$\Gamma,x:\tau \vdash x:\tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1 : \sigma \to \tau$}
\AxiomC{$\Gamma \vdash e_2 : \sigma$}
\RightLabel{(App)}
\BinaryInfC{$\Gamma \vdash e_1\,e_2 : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma,x:\sigma \vdash e : \tau$}
\RightLabel{(Abs)}
\UnaryInfC{$\Gamma \vdash (\lambda x.e) : \sigma \to \tau$}
\end{prooftree}

The first inference rule is for the variable rule, which states that
if $x$ has type $\tau$ in the context $\Gamma$, then $x$ has type
$\tau$. The second inference rule is for the application rule, which
states that if $e_1$ has type $\sigma \to \tau$ and $e_2$ has type
$\sigma$ in the context $\Gamma$, then $e_1\ e_2$ has type $\tau$. By
convention, application is left-associative and parentheses may be
omitted. The third inference rule is for the lambda abstraction rule,
which states that if $e$ has type $\tau$ in the context $\Gamma$
extended with a variable $x$ of type $\sigma$, then $\lambda x.e$ has
type $\sigma \to \tau$.

Polymorphic \lambda-calculus extends STLC by introducing type-level
quantifiers, allowing functions to be defined over types. One example
of a polymorphic \lambda-calculus is System F, which adds the ability
to define functions over types. The quantifiers in System F are
type-level, allowing for more expressive type signatures. Here is an
example of an inference rule for the type abstraction rule in System
F:

\begin{prooftree}
\AxiomC{$\Gamma, \alpha \vdash e:\tau$}
\RightLabel{(TAbs)}
\UnaryInfC{$\Gamma \vdash \Lambda \alpha.e:\forall \alpha.\tau$}
\end{prooftree}

This inference rule shows that if expression $e$ has type $\tau$ in
the context $\Gamma$ extended with a type variable $\alpha$, then the
type abstraction $\Lambda \alpha.e$ has the polymorphic type $\forall
\alpha.\tau$.

Dependent type theory extends System F by allowing types to depend on
terms, enabling more expressivity. The Calculus of Constructions is an
example of dependent type theory that adds the ability to define
functions over types, creating a type hierarchy. The Calculus of
Inductive Constructions extends the Calculus of Constructions with
inductive types, allowing for formalization of mathematical structures
such as natural numbers, lists, and trees.

In the Calculus of Constructions, a key feature is the use of
universes, which are a hierarchy of types that can contain other
types. A universe is a type that can serve as the type of other types,
and universes can contain each other in a hierarchy. For example, the
universe of small types might be contained within a larger universe of
larger types.

Universes are necessary in the Calculus of Constructions because they
allow us to avoid paradoxes that arise when types are allowed to
contain themselves. By separating types into a hierarchy of universes,
we can ensure that any given type is contained in a universe that is
larger than itself, preventing paradoxes such as Girard's paradox
(the type-theoretic analog of Russell's paradox.)\cite{girard_paradox}

Here is an example of a proof rule for the dependent product formation
rule in the Calculus of Constructions:

\begin{prooftree}
\AxiomC{$\Gamma \vdash A \typ \mathbb{U}_i$}
\AxiomC{$\Gamma, x:A \vdash B \typ \mathbb{U}_j$}
\RightLabel{(Prod)}
\BinaryInfC{$\Gamma \vdash (\Pi x:A.B) \typ \mathbb{U}_{\max(i,j)}$}
\end{prooftree}

This inference rule shows that if $A$ has type $\mathbb{U}_i$ and $B$
has type $U_j$ in the context $\Gamma$ extended with variable $x$ of
type $A$, then the dependent product $\Pi x:A.B$ has type
$\mathbb{U}_{\max(i,j)}$. More information about universes can be
found in \cite{ttfp}. An extension to the Predicative Calculus of
Inductive Constructions can be found in \cite{cumulative}.

Dependent type theory provides a foundation for modern proof
assistants such as Coq and Lean, which use the Calculus of Inductive
Constructions as their underlying logic. These proof assistants are
used to formalize mathematics, verify software, and prove the
correctness of algorithms.

** Computation in type theory
The calculi presented so far resembles a Hilbert-style calculus, we
have only considered proof trees that derive well-typed terms. What
distinguishes type theory from other logical calculi is the
computational behavior of the terms. Formally, there is a binary
/evaluation relation/ (often denoted as $\to_\beta$) over the terms. In
the \lambda-calculus, $\to_\beta$ is defined as follows:

\begin{align*}
(\lambda x.f) e &\to_\beta e[f/x]
\end{align*}

Here, $[f/x]$ denotes the substitution of $f$ for free occurrences of
$x$ in $e$. The reflexive transitive closure of $\to_\beta$ is denoted as
$\tred$. Various results exist regarding $\tred$, most notably strong
normalization in typed \lambda-calculi, including for STLC:

\begin{thm*}[Strong Normalization]
For all expressions $e$ of the Simply Typed Lambda Calculus, all reduction sequences beginning with $e$ are finite.
\end{thm*}

A proof of strong normalization and other results can be found in
\cite{ttfp}.

The existence of the untyped calculus is briefly mentioned here. This
is the calculus generated by the \lambda-calculus without any type
restrictions. It is worth noting that strong normalization does not
hold for the untyped calculus, as reduction sequences can be
infinite. However, the untyped calculus still plays a significant role
in the study of \lambda-calculus and its various properties, such as
the Church-Rosser theorem, which states that if a term can be reduced
to two different normal forms, there exists a common reduct for both
of them.

In the context of type theory, the computation rules, such as the
evaluation relation $\to_\beta$, are crucial for connecting the
logical aspects of the type theory with its computational aspects. For
instance, these rules can be used to model the operational semantics
of programming languages and enable the extraction of executable code
from formal proofs. Moreover, the properties of these computation
rules, such as strong normalization, can provide insights into the
decidability and termination of programs and algorithms.

** Curry-Howard correspondence
The Curry-Howard correspondence provides a correspondence between
proof calculi and computational type systems.\cite{wadler} In
propositional logic, a formula consists of either a propositional
variable $X_n$ or a compound formula $A \land B$, $A \lor B$, $A
\implies B$, $\lnot A$, where $A$ and $B$ are formulas. The
Curry-Howard correspondence provides a way to map these logical
formulas to types and lambda terms in a computational type system. The
table below summarizes the correspondence between logic, types, and
sets.

| *Logic*                | *Types*              | *Sets*                          |
|----------------------+--------------------+-------------------------------|
| proposition          | $A$                | set                           |
| proof                | $a : A$            | element                       |
| predicate            | $B(x)$             | family of sets                |
| conditional proof    | $b(x): B(x)$       | family of elements            |
| $\bot,\top$          | 0,1                | $\varnothing,\{\varnothing\}$ |
| $A\lor B$            | $A + B$            | disjoint union                |
| $A\land B$           | $A \times B$       | cartesian product             |
| $A\implies B$        | $A \to B$          | set of functions              |
| $\exists_{x:A} B(x)$ | $\sum_{x:A} B(x)$  | disjoint union of families    |
| $\forall_{x:A} B(x)$ | $\prod_{x:A} B(x)$ | cartesian product of families |

For STLC, the Curry-Howard correspondence can be viewed as a theorem
that relates the derivation of any judgement
$x_1:A_1,\ldots,x_n:A_n\vdash B$ with a lambda term $M$ such that
$x_1:A_1,\ldots,x_n:A_n\vdash M : B$ is a valid typing judgement. In
other words, each valid proof in propositional logic corresponds to a
valid lambda term in STLC, and vice versa.

The Curry-Howard correspondence also occurs at the level of proofs and
programs. Further details can be read in \cite{ttfp} and
\cite{wadler}.

| *Logic*                    | *Types*                  |
|--------------------------+------------------------|
| undischarged assumptions | free variables         |
| discharged assumptions   | bound variables        |
| simplification of proofs | evaluation of programs |


** Constructing new types in type theory
In type theory, it is possible to introduce new types by either
defining them as inductive types or by defining them as dependent
types. The ability to construct new types is a fundamental aspect of
type theory that enables the encoding of complex mathematical
structures.

In STLC, only base types and function types can be defined. Base types
are fixed by the language, while function types are constructed using
the arrow operator $\to$. For example, the type of a function that
takes an integer as input and returns a boolean as output can be
written as $int \to bool$.

In System F, polymorphic types can be defined using universal
quantification. For example, the identity function can be defined with
type $\forall \alpha. \alpha \to \alpha$, where $\alpha$ is a type
variable ranging over all possible types. This type captures the
essence of the identity function, which takes any input of any type
and returns the same value.

In the Calculus of Constructions, new types can be defined using
dependent products, dependent sums, and inductive types. A dependent
product is a type of the form $\prod_{x:A} B(x)$, where $A$ is a type
and $B : A \to \mathbb{U}$ is a type that depends on $x$. This type
can be interpreted as the type of functions that take an input of type
$A$ and return an output of type $B(x)$ for some $x$. For example, the
dependent product $\prod_{n:\mathbb{N}}\mathbb{R}^n$ represents the
type of functions that take an input $n$ representing the dimension of
a vector and return an output of type $\mathbb{R}^n$ representing a
vector in \(n\)-dimensional space. Note that if $B : A \to \mathbb{U}$
is a constant function, the dependent product $\prod_{x:A} B(x)$ is
the same as the function type $A \to B$.

A dependent sum is a type of the form $\sum_{x:A} B(x)$, where $A$ is
a type and $B(x)$ is a type that depends on $x$. This type can be
interpreted as the type of pairs $(a,b)$ where $a$ is an element of
type $A$ and $b$ is an element of type $B(a)$. For example, the
dependent sum $\sum_{n:\mathbb{N}}\mathbb{R}^n$ represents the type of
pairs $(n,v)$ where $n$ is a natural number representing the dimension
of a vector and $v$ is an element of type $\mathbb{R}^n$ representing
a vector in \(n\)-dimensional space.


** Inductive Types in the Calculus of Constructions
Inductive types allow for the construction of new types using
constructors that create new elements of the type. For example, the
natural numbers can be defined as an inductive type with constructors
$0$ and $succ$. Formally,

*Formation Rule for* $\mathbb{N}$
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\mathbb{N} : \mathbb{U}$}
\end{prooftree}

*Introduction Rules for* $\mathbb{N}$
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$0 : \mathbb{N}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n : \mathbb{N}$}
\UnaryInfC{$succ\,n : \mathbb{N}$}
\end{prooftree}

This definition introduces a new inductive type $\mathbb{N}$ with two
constructors 0 and /succ/, and is a type that belongs to the universe.
In terms of metatheory, when we construct an inductive type, we are
taking the fixpoint of a monotonic operation on types $\Theta :
\mathbb{U}\to\mathbb{U}$. Relevant details may be found in Section
7.10 of \cite{ttfp}.

** Equality in dependent type theory
Although the dependent type theory presented so far seems
inexpressive, we can begin to introduce predicates of interest. We
only show a simple example but for full details refer to \cite{ttfp}.

We would like to define propositional equality, to make the logical
assertion regarding two terms $a$ and $b$ as:

\begin{center}
`$a$ and $b$ are equal elements of the type $A$'
\end{center}

In order to do this, we need to introduce a new type $I$ that can
represent the equality of two elements of a given type. We can define
$I$ as follows:

*Formation Rule for* $I$
\begin{prooftree}
\AxiomC{$A : \mathbb{U}$}
\AxiomC{$a : A$}
\AxiomC{$b : A$}
\TrinaryInfC{$I(A,a,b) : \mathbb{U}$}
\end{prooftree}

*Introduction Rule for* $I$
\begin{prooftree}
\AxiomC{$A : \mathbb{U}$}
\AxiomC{$a : A$}
\BinaryInfC{$\text{refl}\,A\,a : I(A,a,a)$}
\end{prooftree}

The formation rule states that $I$ is parameterized by a type $A$ and
two elements $a$ and $b$ of type $A$. The introduction rule states
that for all types $A$ and elements $a$ of type $A$, there is a proof
that $a$ is equal to itself. The following result allows us to use
this definition of propositional equality to rewrite terms that have
a proof of equality between them.

\begin{thm*}
Leibnitz's law is derivable. That is, if we have a type $P(a)$ that
depends on $a$ and $c : I(A,a,b)$, then we can conclude $P(b)$.
\end{thm*}

A proof of this theorem can be found in \cite{ttfp}. Note that this is
different from definitional equality, where convertible or terms that
are equivalent under evaluation may be substituted freely within the
type theory.


** Interactions between axioms in dependent type theory
Under the Curry-Howard correspondence, disjunction corresponds to sum
types. We are also able to define the empty type $\bot$ corresponding
to the always false statement. Thus we can consider the type $\forall
(P : \mathbb{U}),\, P\vee\neg P$. If this type were inhabited, it would
imply a way of selecting an element from every nonempty
type.\cite{hott} For a particular $P$, it is possible to write a term
that yields a proof of $P$ or its negation, but this is not assumed to
be given in general.

In dependent type theory, we must take care when adding extra
assumptions, since they may interact in subtle ways that allow for LEM
to be proven. For instance, assuming propositional extensionality and
decidable equality implies LEM:

\begin{thm*}
Propositional extensionality (PropExt) and decidable equality
(DecEq) together imply LEM.
\end{thm*}

\begin{proof}
Assume PropExt, that is, for all propositions $P$, $Q$,
$P\leftrightarrow Q$ implies $P=Q$. Assume DecEq, that is, for all
types $X$ and members $a$, $b$ of type $X$, either $a=b$ or $a\neq b$.

First we prove a small lemma that for all propositions $P$,
$P=(P=\top)$. That is, a proposition $P$ is equal to a proof of
equality between $P$ and $\top$, which has a single trivial
inhabitant. By PropExt, it suffices to prove
$P\leftrightarrow (P=\top)$.

$(\Rightarrow)$ Assume $P$. We want to show $P=\top$. By PropExt,
it suffices to show $P\leftrightarrow\top$, which is trivial because
we have a proof of $P$ and the trivial proof for $\top$.

$(\Leftarrow)$ Assume $P=\top$. We want to show $P$. This is trivial
since using the assumption we have to prove $\top$.

Now, assume DecEq and PropExt and fix an arbitrary proposition
$P$. From DecEq we have that $P = \top \vee P \neq\top$. This is
equivalent to $P=\top\vee((P=\top)\to\bot)$. From the lemma we have
$P\vee(P\to\bot)$ thus we have $P\vee\neg P$, thus $P$ is decided.
\end{proof}

For completeness, Listing [[fig:coq_proof_lem1]] shows the formal proof of
this theorem in Coq. For more discussion regarding the subtleties of
LEM and its implications for mathematical results when not assumed,
see \cite{bauer}.

#+CAPTION: Formal Coq proof of LEM from PropExt and DecEq.
#+NAME: fig:coq_proof_lem1
#+BEGIN_src coq
Definition prop_ext := forall (P Q : Prop), (P <-> Q) -> P = Q.
Definition dec_eq := forall (X : Type) (a b : X), a = b \/ a <> b.
Definition lem := forall (P : Prop), P \/ ~ P.

Lemma small_lemma : forall (P : Prop), prop_ext -> P = (P = True).
Proof.
  intros P prop_ext.
  apply prop_ext.
  split; intros; [apply prop_ext|rewrite H]; firstorder.
Qed.

(* LEM follows from prop_ext and dec_eq *)
Lemma prop_ext_deceq_lem : prop_ext -> dec_eq -> lem.
Proof.
  unfold dec_eq, lem.
  intros prop_ext dec_eq P.
  rewrite (small_lemma P); [apply dec_eq|apply prop_ext].
Qed.
#+END_src

* Overview of Coq
Coq\cite{coqart} is a proof assistant for writing mathematical
statements, constructing their proofs and mechanically checking the
validity of their proofs. The logical foundation of Coq is the
Calculus of Inductive Constructions. There are many resources and
guides on various aspects of Coq applied in different contexts, such
as program verification or mechanization of
mathematics.\cite{cpdt}\cite{sergey}\cite{sf}

Coq consists of two languages, /Gallina/ and /Ltac/. Gallina is the
specification language of Coq and can be thought of as the underlying
term language. Gallina is purely functional and has support for
dependent types and dependent pattern matching. /Ltac/ is the tactic
language of Coq and is what is used to carry out formal proofs. An
introduction to Ltac and Coq can be found in \cite{tactic} and
\cite{hurry} respectively. It suffices to say that, from a usability
standpoint, \textit{Ltac} commands operate on the current
\textit{proof state}, which is the context consisting of hypothesis
and a goal. The commands may introduce new hypotheses, clear existing
ones, allow application of one hypothesis to another, discriminate a
value in context, and so on.

** Definitions
# non-inductive type definition explanation

Inductive types are defined using the ~Inductive~ keyword followed by
the name of the type and its constructors.

For example, the natural numbers can be defined in Coq as follows:

#+BEGIN_SRC coq
Inductive nat : Type :=
| O : nat
| S : nat -> nat.
#+END_SRC

This definition introduces a new type nat with two constructors ~O~ and
~S~, representing zero and successor, respectively. The constructor ~S~
takes an argument of type nat and returns a new nat representing its
successor.

Lists can also be defined as an inductive type in Coq, with two
constructors ~nil~ and ~cons~ representing the empty list and the cons
operation, respectively:

#+BEGIN_SRC coq
Inductive list (A : Type) : Type :=
| nil : list A
| cons : A -> list A -> list A.
#+END_SRC

This definition introduces a new list type parameterized over a type
~A~, with two constructors ~nil~ and ~cons~. The constructor ~cons~ takes an
element of type ~A~ and a list of type ~list A~, and returns a new list
with the element added to the front.

Here is an example of a Coq function that computes the length of a
list recursively:

#+BEGIN_SRC coq
Fixpoint length {A : Type} (l : list A) : nat :=
match l with
| nil => O
| cons _ xs => S (length xs)
end.
#+END_SRC

** Proof Engineering
In the last few decades, the practice of /proof engineering/ has emerged
whereby formal developments are carried out and maintained at
scale. Many proof engineering techniques take inspiration from work in
software engineering.\cite{klein2014proof} An extensive survey can be
found in \cite{ringer2019qed}. Although the logical foundations of
proof assistants are for the most part fixed, the practices and
conventions surrounding the development of theories are constantly in
flux.

* Building graph theory in Coq
In this section, we will present how we carried out our own
development of graph theory in Coq. Section [[Survey of graph theory
developments in Coq]] will provide comparison as to how the design
choices here fit in the formalization landscape. The full repository
containing the definitions and proofs can be found in
\cite{wigderson-siraben}. We also provide a printout of the source for
the theory of subgraphs in Section [[Appendix A: A formal theory of
graphs]].


** Preliminary definitions
We use the definition of graphs as defined in Volume 3 of \cite{sf} as
a starting point. Listing [[fig:coq_graph_def]] shows the preliminary
definitions of the development. We choose to have vertices be
represented as positive integers, and choose an adjacency set
representation. That is, a graph ~G~ is a finite map from positive
integers to sets of positive integers, representing vertices and their
adjacent vertices respectively.

#+CAPTION: Definition of graphs in Coq.
#+NAME: fig:coq_graph_def
#+BEGIN_SRC coq
Module E := PositiveOrderedTypeBits.
Module S <: FSetInterface.S := PositiveSet.
Module M <: FMapInterface.S := PositiveMap.

Definition node := E.t.
Definition nodeset := S.t.
Definition nodemap: Type -> Type := M.t.
Definition graph := nodemap nodeset.

Definition adj (g: graph) (i: node) : nodeset :=
  match M.find i g with Some a => a | None => S.empty end.

Definition undirected (g: graph) :=
   forall i j, S.In j (adj g i) -> S.In i (adj g j).

Definition no_selfloop (g: graph) := forall i, ~ S.In i (adj g i).

Definition nodes (g: graph) := Mdomain g.
#+END_SRC

The ~adj~ function takes a graph, a vertex and returns a ~nodeset~ (which
is empty if the vertex is not in the graph). The ~undirected~ predicate
states that a graph is undirected if for every pair of vertices ~i~ and
~j~, if ~j~ is in ~i~'s adjacency set then ~i~ is in ~j~'s adjacency
set. ~no_selfloop~ states that a graph is irreflexive if ~i~ is never
contained in its own vertex set. Finally, ~nodes~ takes the
representation of the graph and extracts the key entries
(resp. vertices) of the graph.

For the rest of the development, we will present it backwards from
formalizing a graph coloring algorithm so as to show the process of
how we started with a high-level theorem and worked to find
appropriate lemmas and structures.

* Formalizing Wigderson's algorithm in Coq
Our main contribution is progress towards the formalization of key
lemmas for the proof of correctness of Wigderson's
algorithm. Wigderson's algorithm\cite{wigderson} is an approximate
graph coloring algorithm that aims to color a 3-colorable graph
with at most $3\sqrt{n}$ colors in polynomial time. If the graph is
not 3-colorable, then either a valid approximation is returned or the
a certification that the input was not 3-colorable.

Our development will closely follow the paper by
Wigderson\cite{wigderson} in which he presents a proof of correctness
with the given color bound and its polynomial running time, with
appropriate lemmas. First we present an imperative version of the
algorithm then its purely functional equivalent. Then we explore in
detail key lemmas and theories that must be built up for us to reason
about correctness of the algorithm.

The idea of Wigderson's algorithm is to find vertices with degree of
least \(k\). Finding these high-degree vertices allows us to color
more vertices at once since we are able to 2-color the neighborhood
for each of these vertices. Then we remove the colored vertices and
continue this until no such high-degree vertices remain. Then color
the remaining vertices with new colors. Then the pseudocode algorithm
he is as follows where $\Delta(G)$ is the maximum degree of any vertex
in $G$:

#+CAPTION: Wigderson's 3-coloring algorithm.
#+BEGIN_algorithm
\hspace*{\algorithmicindent}\textbf{Input:} A 3-colorable graph $G(V, E)$
\begin{algorithmic}[1]
\State $n \gets |V|$
\State $i \gets 1$
\While {$\Delta(G) \geq k$}
\State $H \gets$ the subgraph of $G$ induced by the neighborhood $N_G(v)$
\State 2-color $H$ with colors $i, i+1$
\State color $v$ with color $i + 2$.
\State $i \gets i + 2$
\State $G \gets$ the subgraph of $G$ resulting from it by deleting $N_G(v) \cup \{v\}$
\EndWhile
\State color $G$ with colors $i, i + 1, i + 2, \dots, \Delta (G)$ and halt
\end{algorithmic}
#+END_algorithm

** Informal proof of correctness
In a 3-colorable graph, the neighborhood of any vertex must be one of
the two other colors, so the neighborhood of that vertex is
2-colorable. We can find a 2-coloring easily in linear time by
recursively forcing colors. We do this for vertices with higher
degrees to eliminate as many colors as possible. Finally, we naively
color the remaining vertices.

In the while loop, $i$ is incremented by $2$ and $3$ colors are
used. This means there will be overlap between the final color used on
the current iteration and the first color used on the next
iteration. This is possible since the final color assigned on each
iteration is to $v$. Since the neighborhood of $v$, $N_G(v)$ was
already colored, reusing this color for other vertices will not cause
any contradictions. To make verification easier, we fix the color of
high-degree to color 1 on every iteration and use two unique colors
for the neighborhoods.

** Finding a bound on the number of colors used
Let $n$ be the number of vertices in the graph. In a dense graph, it
is possible that all vertices have at least degree \(k\), but each
iteration also removes at least $k + 1$ vertices from the graph. We
can remove at most $n$ vertices, so $(k+1)x \leq n$ where $x$ is the
number of iterations, and thus $x \leq \frac{n}{k+1}$. Then once the
loop terminates, then $\Delta(G) < k$, so we can use a polynomial time
algorithm to color these vertices using at most $1 + \Delta(G) < 1 +
k$ colors. Therefore, we use at most \(k\) colors to color these
vertices. This gives an upper bound of $k + \frac{2n}{k}$ colors used
since there are $2$ new colors used each iteration. We want to balance
these two terms by selecting an appropriate \(k\) as follows

\begin{align*}
    k &= \frac{2n}{k} \\
    k^2 &= 2n \\
    k &= \sqrt{2n}
\end{align*}

This leads to a bound of $\sqrt{2n} + \frac{2n}{\sqrt{2n}} =
2\sqrt{2n} = \sqrt{8}\sqrt{n} \approx 2.828\sqrt{n} =
O(\sqrt{n})$. For sake of simplicity, we will use $k = \sqrt{n}$ as
Wigderson did. This will give us a bound of $\sqrt{n} +
\frac{2n}{\sqrt{n}} = 3\sqrt{n} = O(\sqrt{n})$. This proves the bound.

** Translation to a functional algorithm
We want to further explain the steps of the algorithm to convert this into a functional program to be used in Coq. We use the updated color assignment process we described and use the value $k = \sqrt{n}$. The algorithm can be described in two phases: the first where we color the high-degree vertices and their neighborhoods, and the second is coloring the remaining vertices. We first present the pseudocode for both Phase I and Phase II of the algorithm, each of which are divided into further subroutines.

\begin{algorithm}
\caption{Phase I Algorithm}
\hspace*{\algorithmicindent}\textbf{Input:} A graph $G(V, E)$ with $|V| = n$
\begin{algorithmic}[1]
\Function{two-color-vertex}{$v, c_1, c_2$}
  \State Color $v$ with color $c_1$
  \If{$v$ has any uncolored neighbors}
    \State \Call{two-color-vertex}{$x, c_2, c_1$} for all uncolored neighbors $x$ of $v$
  \EndIf
  \State \Return new coloring of $G$
\EndFunction
\Function{two-color-neighborhood}{coloring $f$ of $N$}
  \If{there exists an uncolored vertex in $f$}
    \State $v \gets$ the first uncolored vertex from $f$
    \State $f \gets$ \Call{two-color-vertex}{$v, c_1, c_2$}
    \State \Call{two-color-neighborhood}{$f$}
  \EndIf
  \State \Return $f$
\EndFunction
\Function{phase-1}{graph $G(V, E)$}
  \State $f \gets$ empty coloring
  \If{there exists a vertex with degree at least $\sqrt{n}$}
    \State $v \gets$ first vertex with degree at least $\sqrt{n}$
    \State $f \gets$ $f$ with $v$ assigned color $1$
    \State $f \gets$ \Call{two-color-neighborhood}{$f$}
    \State $G \gets G - (v \cup N_G(v))$
    \State $f, G \gets$ \Call{phase-1}{$G$}
  \EndIf
  \State \Return $f, G$
\EndFunction
\State \Return \Call{phase-1}{$G$}
\end{algorithmic}
\end{algorithm}

In Phase I, the first function two-colors the connected component of a vertex. It arbitrarily selects a color and forces the adjacent vertices until we must arbitrarily select another color for the next connected component. The next function applies this to the whole neighborhood of a vertex. Finally, the Phase I function selects high-degree vertices and colors them and their neighborhoods until there are no more high-degree vertices remaining. This leaves us with a graph with no high degree vertex in which we will then use for Phase II.

\begin{algorithm}
\caption{Phase II Algorithm}
\hspace*{\algorithmicindent}\textbf{Input:} A graph $G(V, E)$ with maximum degree $d$
\begin{algorithmic}[1]
\Function{color-d}{$G, d, c, f$}
  \If{there exists a vertex with degree $d$}
    \State $v \gets$ first vertex with degree $d$ in $G$
    \State $f \gets f$ with color $c$ assigned to $v$
    \State remove $v$ from $G$
    \State \Return \Call{color-d}{$G, d, c, f$}
  \EndIf
  \State \Return $G$
\EndFunction
\Function{color-all-d}{$G, d, f$, colors $c_0, c_2, \dots, c_d$}
  \If{$d \geq 0$}
    \State $G \gets$ \Call{color-d}{$G, d, c_d, f$}
    \State \Return \Call{color-all-d}{$G, d-1, f, c_0, \dots, c_{d-1}$}
  \EndIf
  \State \Return $G, f$
\EndFunction
\State \Return \Call{color-all-d}{$G, d, f, c_0, \dots, c_d$}
\end{algorithmic}
\end{algorithm}

In phase II, the goal is to color the remaining graph with $d+1$ colors where $d$ is the maximum degree of the graph. The first function removes (non-adjacent) vertices with degree $d$ and assigns them the same color. The second function simply applies this for all degrees from $d$ down to $0$ which will fully color the graph with $d+1$ colors.

** Understanding Correctness and Robustness
We will now present the informal proofs of correctness to help us translate these ideas formally into Coq.
\begin{lem}
    The subgraph formed by the neighborhood of a vertex in a $n$-colorable graph is $(n-1)$-colorable.
    \begin{proof}
        Let $G$ be a $n$-colorable graph and let $v$ be an arbitrary vertex in $G$. Then there exists a coloring of $G$ using at most $n$ different colors. Vertex $v$ must be assigned some color $c$. Then all vertices adjacent to $v$ i.e. the neighborhood of $v$ will have colors different than $c$. Since the graph is $n$-colorable, one of these being $c$, the neighborhood can only use at most $n-1$ colors.
    \end{proof}
\end{lem}

In the Phase I algorithm, we attempt to 2-color each neighborhood of
high-degree vertices. For a 2-colorable graph, the 2-coloring function
will work since we are simply forcing the choices logically. If this
2-coloring fails, then the neighborhood is not two colorable, and by
the lemma, this means the graph is not 3-colorable. In this case, we
simply return this as a certificate that the input graph was not
3-colorable. The color of the high-degree vertex will be assigned
color $1$. For the next high-degree vertex, each of its neighbors
cannot be a high-degree vertex already used since this would mean the
vertex would have been colored. Thus, we can reuse the color $1$. Each
step uses $\sqrt{n}$ new vertices, so this means there are at most
$\frac{n}{\sqrt{n}} = \sqrt{n}$ iterations. This means there are
$2\sqrt{n} + 1$ colors in this process. Since the loop terminates when
there are no more vertices of at least degree $\sqrt{n}$, we know that
after this process the uncolored vertices will have degree less than
$\sqrt{n}$ i.e. maximum degree is at most $\sqrt{n} - 1$. The final
process simply requires assigning different colors for each
degree. Since we can assign the same color to each vertex in a
1-colorable graph, Phase II will work by induction. If we assume the
process will succeed for $d-1$ and produce a \(d\)-coloring, then we
remove each vertex with degree $d$. We cannot remove two neighboring
vertices since the degree of the neighbors will decrease by 1 once
remove. Therefore, we can use this color added to the \(d\)-coloring
to form a $d+1$ coloring as desired. This gives us a total of
$3\sqrt{n} + 1$ colors (we can reuse a color in the final step to
obtain $3\sqrt{n}$).


* Wigderson's Coloring Approximation Algorithm

For now, we will assume that any input graph is 3-colorable before we
discuss robustness.



We define a coloring as a map from the vertices to a set of
colors. This coloring is considered a \(k\)-coloring for a set of size
at at most \(k\). We say a graph is \(k\)-colorable if there exists a
\(k\)-coloring.

This means that the coloring is induced from the
3-coloring, so we need to define this notion formally. With our
definition, if we assume a graph is 3-colorable, then we can use the
3-coloring given to us by Coq. Our goal is to only use these colorings
for establishing definitions and lemmas and not as the coloring
generated by the algorithm.

We must define the concept of a neighborhood, but before we can do that, we need to a define a subgraph. This is simply a subset of vertices whose adjacency lists are subset of the adjacency lists of the entire graph. In Coq we have

#+BEGIN_SRC coq
Definition is_subgraph (g' g : graph) :=
  S.Subset (nodes g') (nodes g) /\ forall v, S.Subset (adj g' v) (adj g v).
#+END_SRC

Then an induced subgraph is the subgraph generated from a subset of vertices in which each edge in the original graph between these vertices is contained in the subgraph.

#+BEGIN_SRC coq
Definition subgraph_of (g : graph) (s : S.t) : graph :=
  M.fold (fun v adj g' => if S.mem v s then M.add v (S.inter s adj) g' else g')
         g
         empty_graph.
#+END_SRC

Combining these definitions, the neighborhood of a vertex $v$ is the induced subgraph formed by the set of neighbors of $v$ with $v$ removed.

#+BEGIN_SRC coq
Definition neighborhood (g : graph) v :=
   remove_node v (subgraph_of g (neighbors g v)).
#+END_SRC

Now we define what a coloring is and what it mean for a coloring to be OK and complete on a graph. A coloring is a map from vertices to colors. A coloring $f$ is OK on a graph $g$ with respect to a palette $p$ if for every adjacent pair $i$, $j$, if $i$ is colored then $f(i)\in p$ and if $j$ is colored then $f(j)\in p$ and $f(i)\ne f(j)$. A coloring is complete if every vertex in $g$ has a color and the coloring is OK. This is an important distinction to make because the colorings that our algorithm builds up are partial and must be combined to eventually make a complete coloring.

#+BEGIN_SRC coq
Definition colors := S.t.
Definition coloring := M.t node.
Definition coloring_ok (palette: S.t) (g: graph) (f: coloring) :=
 forall i j, S.In j (adj g i) ->
     (forall ci, M.find i f = Some ci -> S.In ci palette) /\
     (forall ci cj, M.find i f = Some ci -> M.find j f = Some cj -> ci<>cj).
Definition coloring_complete (palette: colors) (g: graph) (f: coloring) :=
 (forall i, M.In i g -> M.In i f) /\ coloring_ok palette g f.
#+END_SRC

Now, combining colorings and neighborhoods, we can talk about what it means to restrict a coloring on a neighborhood of a vertex.

#+BEGIN_SRC coq
Definition restrict_on_nbd (f : coloring) (g : graph) (v : node) :=
  restrict f (nodes (neighborhood g v)).
#+END_SRC


** Organization of the theory
The theory is organized into a series of modules, each of which is
defined in a separate file.

#+CAPTION: Statistics of our graph theory development.
| *Filename*    | *Blank lines* | *Comment lines* | *Code lines* |
|-------------+-------------+---------------+------------|
| ~subgraph.v~  |         138 |           131 |       1145 |
| ~coloring.v~  |          80 |           146 |        994 |
| ~graph.v~     |         122 |           173 |        407 |
| ~wigderson.v~ |          47 |           119 |        228 |
| ~restrict.v~  |          14 |             6 |        181 |
| ~munion.v~    |           6 |             6 |         63 |
|-------------+-------------+---------------+------------|
| *Total*       |         407 |           581 |       3018 |
#+TBLFM: @>$2=vsum(@I..@II)::@>$3=vsum(@I..@II)::@>$4=vsum(@I..@II)


** Example lemma: maximum degree and subgraphs
To illustrate the level of detail that is required in a formal proof
and to motivate introspection into implicit assumptions about graphs,
we will deconstruct a lemma about how maximum degrees interact with
the subgraph relation.

*Lemma.* Let ~G'~ be a subgraph of ~G~. Then ~max_deg G' <= max_deg G~.

*Proof.* When ~max_deg G'~ is zero, this is immediate. Otherwise, there is
some vertex ~k~ of non-zero maximum degree in ~G'~. Since ~G'~ is a subgraph
of ~G~, this vertex ~k~ is also in ~G~. Since ~G'~ is a subgraph of ~G~, the
pointwise vertex sets of ~G'~ are subsets of the corresponding vertex
set in ~G~. In particular, ~G'[k]~ is a subset of ~G[k]~. Let ~t~ be the
vertex of (non-zero) maximum degree in ~G~. Since ~t~ is a vertex of
maximum degree, the size of ~G[t]~ bounds the size of all other vertex
sets, in particular ~G[k]~. Thus, ~max_deg G' = G'[k] <= G[k] <= G[t] =
max_deg G~, as desired.

* Formalizing Wigderson's Algorithm in Coq



\newpage

* Survey of graph theory developments in Coq
** Mathematical Components


** Doczkal and Pous
Doczkal and Pous develop graph theory in Coq to reason about minors,
treewidth and isomorphisms.\cite{doczkal}


** CertiGraph
Wang et al. develops mechanized graph theory as a necessary component
of being able to reason about graph-manipulating programs written in
CompCert C, a dialect of the C programming language that has a
verified compiler (i.e. the preservation of the semantics of the
source and compiled programs is formally stated and proved). To the
author's knowledge, this is one of the most comprehensive general
development of graph theory in Coq to date.\cite{wang}

# cite Wang thesis: Mechanized Verification of Graph-Manipulating
# Programs
In Wang 2019, particular attention was paid to the definition of
graphs in order to retain as much generality as possible. The base
construction of the graph is as follows:

#+begin_src coq
Definition Ensemble (U : Type) := U -> Prop.
Record PreGraph (Vertex Edge : Type)
                {EV: EqDec Vertex eq} {EE: EqDec Edge eq} := {
  vvalid : Ensemble Vertex;
  evalid : Ensemble Edge;
  src : Edge -> Vertex;
  dst : Edge -> Vertex
}.
#+end_src

That is, we start with a notion of a ~PreGraph~, which is a record
parameterized over types ~Vertex~ and ~Edge~ (corresponding to the types
for vertices and edges respectively), along with proofs of decidable
equality over those types.  As we have seen in a previous section,
decidable equality for types is not guaranteed in the same way it is
for set theory.  In the context of graph-manipulating programs, Wang
states that decidable equality ``is such a fundamental property that
almost all sensible graph-manipulating algorithms employ it whether or
not they realize it''.


* Conclusion and future work

\newpage
* Appendix A: A formal theory of graphs
We fully annotate one of the main files concerning subgraphs used in
the formalization of graph theory. Every lemma shown here is fully
formalized and can be viewed online [[https://github.com/siraben/coq-wigderson/blob/3ec8b9b704199da83383c65cc68fc63126d57b77/subgraph.v][here]].

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{graph}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{List}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{Setoid}. \coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{FSets}. \coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{FMaps}. \coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{PArith}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{Psatz}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{restrict}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{Program}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{FunInd}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqdocvar{Decidable}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Hammer} \coqdockw{Require} \coqdockw{Import} \coqdocvar{Hammer}.\coqdoceol
\coqdocnoindent
\coqdockw{From} \coqdocvar{Hammer} \coqdockw{Require} \coqdockw{Import} \coqdocvar{Tactics}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{Arith}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{ListNotations}.\coqdoceol
\coqdocnoindent
\coqdockw{Import} \coqdocvar{Nat}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Local Open} \coqdockw{Scope} \coqdocvar{nat}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Properties of subgraphs and degrees}



\subsubsection{Subgraph predicate}


 \coqdocvar{g'} is a subgraph of \coqdocvar{g} if:

\begin{itemize}
\item  the vertex set of \coqdocvar{g'} is a subset of the vertex set of \coqdocvar{g}

\item  the adjacency set of every \coqdocvar{v} in \coqdocvar{g'} is a subset of adjacency set of every \coqdocvar{v} in \coqdocvar{g}


\end{itemize}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{is\_subgraph} (\coqdocvar{g'} \coqdocvar{g} : \coqdocvar{graph}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{S.Subset} (\coqdocvar{nodes} \coqdocvar{g'}) (\coqdocvar{nodes} \coqdocvar{g}) \ensuremath{\land} \coqdockw{\ensuremath{\forall}} \coqdocvar{v}, \coqdocvar{S.Subset} (\coqdocvar{adj} \coqdocvar{g'} \coqdocvar{v}) (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{v}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Subgraph relation is reflexive}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subgraph\_refl} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g}, \coqdocvar{is\_subgraph} \coqdocvar{g} \coqdocvar{g}.\coqdoceol
 \coqdocemptyline
\end{coqdoccode}
\subsubsection{Subgraph relation is transitive}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subgraph\_trans} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{g'} \coqdocvar{g'{}'}, \coqdocvar{is\_subgraph} \coqdocvar{g} \coqdocvar{g'} \ensuremath{\rightarrow} \coqdocvar{is\_subgraph} \coqdocvar{g'} \coqdocvar{g'{}'} \ensuremath{\rightarrow} \coqdocvar{is\_subgraph} \coqdocvar{g} \coqdocvar{g'{}'}.\coqdoceol
 \coqdocemptyline
\end{coqdoccode}
\subsubsection{Subgraphs preserve irrelexivity}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subgraph\_no\_selfloop} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g'} \coqdocvar{g}, \coqdocvar{is\_subgraph} \coqdocvar{g'} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{no\_selfloop} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{no\_selfloop} \coqdocvar{g'}.\coqdoceol
 \coqdocemptyline
\end{coqdoccode}
\subsubsection{Vertices in the subgraph are in original graph}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subgraph\_vert\_m} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g'} \coqdocvar{g} \coqdocvar{v}, \coqdocvar{is\_subgraph} \coqdocvar{g'} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{M.In} \coqdocvar{v} \coqdocvar{g'} \ensuremath{\rightarrow} \coqdocvar{M.In} \coqdocvar{v} \coqdocvar{g}.\coqdoceol
 \coqdocemptyline
\end{coqdoccode}
\subsubsection{Empty graph is a subgraph}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{empty\_subgraph\_is\_subgraph} (\coqdocvar{g} : \coqdocvar{graph}) : \coqdocvar{is\_subgraph} \coqdocvar{empty\_graph} \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Induced subgraphs}

\subsubsection{Definition}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{subgraph\_of} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{s} : \coqdocvar{S.t}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{M.fold} (\coqdockw{fun} \coqdocvar{v} \coqdocvar{adj} \coqdocvar{g'} \ensuremath{\Rightarrow} \coqdockw{if} \coqdocvar{S.mem} \coqdocvar{v} \coqdocvar{s} \coqdockw{then} \coqdocvar{M.add} \coqdocvar{v} (\coqdocvar{S.inter} \coqdocvar{s} \coqdocvar{adj}) \coqdocvar{g'} \coqdockw{else} \coqdocvar{g'}) \coqdocvar{g} \coqdocvar{empty\_graph}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Nodes of an induced subgraph are a subset of the original graph}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subgraph\_vertices} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{s}, \coqdocvar{S.Subset} (\coqdocvar{nodes} (\coqdocvar{subgraph\_of} \coqdocvar{g} \coqdocvar{s})) (\coqdocvar{nodes} \coqdocvar{g}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Edges of an induced subgraph are a subset of the original graph}

 Note that this is defined pointwise: the adjacency set is a subset
    for every vertex.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subgraph\_edges} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{s} \coqdocvar{v},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{S.Subset} (\coqdocvar{adj} (\coqdocvar{subgraph\_of} \coqdocvar{g} \coqdocvar{s}) \coqdocvar{v}) (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{v}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Induced subgraph is subgraph}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subgraph\_of\_is\_subgraph} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{s}, \coqdocvar{is\_subgraph} (\coqdocvar{subgraph\_of} \coqdocvar{g} \coqdocvar{s}) \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Removal of nodes}

\subsubsection{Removing a distinct vertex from a graph}

 If \coqdocvar{i} and \coqdocvar{j} are distinct vertices then removing \coqdocvar{j} from the
    graph doesn't affect \coqdocvar{i}'s membership.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_node\_neq} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{i} \coqdocvar{j}, \coqdocvar{i} \ensuremath{\not=} \coqdocvar{j} \ensuremath{\rightarrow} \coqdocvar{M.In} \coqdocvar{i} \coqdocvar{g} \ensuremath{\leftrightarrow} \coqdocvar{M.In} \coqdocvar{i} (\coqdocvar{remove\_node} \coqdocvar{j} \coqdocvar{g}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If \coqdocvar{i} is in the graph with \coqdocvar{j} removed then \coqdocvar{i} is not equal to \coqdocvar{j}.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_node\_neq2} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{i} \coqdocvar{j}, \coqdocvar{M.In} \coqdocvar{i} (\coqdocvar{remove\_node} \coqdocvar{j} \coqdocvar{g}) \ensuremath{\rightarrow} \coqdocvar{i} \ensuremath{\not=} \coqdocvar{j}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Removing a node results in a subgraph}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_node\_subgraph} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{v}, \coqdocvar{is\_subgraph} (\coqdocvar{remove\_node} \coqdocvar{v} \coqdocvar{g}) \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Removing a node}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_node\_not\_in} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{g'} \coqdocvar{v},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{is\_subgraph} \coqdocvar{g'} (\coqdocvar{remove\_node} \coqdocvar{v} \coqdocvar{g}) \ensuremath{\rightarrow} \ensuremath{\lnot} \coqdocvar{M.In} \coqdocvar{v} \coqdocvar{g'}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Remove a set of vertices from a graph}

 To make it easier to prove things about it,

\begin{itemize}
\item  first restrict the graph by \coqdocvar{S.diff} (\coqdocvar{Mdomain} \coqdocvar{g}) \coqdocvar{s}

\item  then map subtracting s from every adj set


\end{itemize}
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{remove\_nodes} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{s} : \coqdocvar{nodeset}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{M.map} (\coqdockw{fun} \coqdocvar{ve} \ensuremath{\Rightarrow} \coqdocvar{S.diff} \coqdocvar{ve} \coqdocvar{s}) (\coqdocvar{restrict} \coqdocvar{g} (\coqdocvar{S.diff} (\coqdocvar{nodes} \coqdocvar{g}) \coqdocvar{s})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Removing nodes results in a subgraph}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_nodes\_subgraph} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{s}, \coqdocvar{is\_subgraph} (\coqdocvar{remove\_nodes} \coqdocvar{g} \coqdocvar{s}) \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Every vertex in the removing set is not in the resulting graph}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_nodes\_sub} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{s} \coqdocvar{i}, \coqdocvar{S.In} \coqdocvar{i} \coqdocvar{s} \ensuremath{\rightarrow} \coqdocvar{M.In} \coqdocvar{i} \coqdocvar{g} \ensuremath{\rightarrow} \ensuremath{\lnot} \coqdocvar{M.In} \coqdocvar{i} (\coqdocvar{remove\_nodes} \coqdocvar{g} \coqdocvar{s}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Removing a non-empty set of vertices decreases the size of the graph}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_nodes\_lt} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{s} \coqdocvar{i}, \coqdocvar{S.In} \coqdocvar{i} \coqdocvar{s} \ensuremath{\rightarrow} \coqdocvar{M.In} \coqdocvar{i} \coqdocvar{g} \ensuremath{\rightarrow} (\coqdocvar{M.cardinal} (\coqdocvar{remove\_nodes} \coqdocvar{g} \coqdocvar{s}) < \coqdocvar{M.cardinal} \coqdocvar{g}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{adj\_remove\_nodes\_spec} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{s} \coqdocvar{i} \coqdocvar{j},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{S.In} \coqdocvar{i} (\coqdocvar{adj} (\coqdocvar{remove\_nodes} \coqdocvar{g} \coqdocvar{s}) \coqdocvar{j}) \ensuremath{\leftrightarrow} \coqdocvar{S.In} \coqdocvar{i} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{j}) \ensuremath{\land} \ensuremath{\lnot} \coqdocvar{S.In} \coqdocvar{i} \coqdocvar{s} \ensuremath{\land} \ensuremath{\lnot} \coqdocvar{S.In} \coqdocvar{j} \coqdocvar{s}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_nodes\_singleton} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{v}, \coqdocvar{M.Equiv} \coqdocvar{S.Equal} (\coqdocvar{remove\_nodes} \coqdocvar{g} (\coqdocvar{S.singleton} \coqdocvar{v})) (\coqdocvar{remove\_node} \coqdocvar{v} \coqdocvar{g}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_node\_nodes\_adj} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{i} \coqdocvar{v},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{S.Equal} (\coqdocvar{adj} (\coqdocvar{remove\_nodes} \coqdocvar{g} (\coqdocvar{S.singleton} \coqdocvar{v})) \coqdocvar{i}) (\coqdocvar{adj} (\coqdocvar{remove\_node} \coqdocvar{v} \coqdocvar{g}) \coqdocvar{i}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{adj\_remove\_node\_spec} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{v} \coqdocvar{i} \coqdocvar{j},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{S.In} \coqdocvar{i} (\coqdocvar{adj} (\coqdocvar{remove\_node} \coqdocvar{v} \coqdocvar{g}) \coqdocvar{j}) \ensuremath{\leftrightarrow} \coqdocvar{S.In} \coqdocvar{i} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{j}) \ensuremath{\land} \coqdocvar{i} \ensuremath{\not=} \coqdocvar{v} \ensuremath{\land} \coqdocvar{j} \ensuremath{\not=} \coqdocvar{v}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Removing a subgraph preserves undirectedness}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_nodes\_undirected} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{s}, \coqdocvar{undirected} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{undirected} (\coqdocvar{remove\_nodes} \coqdocvar{g} \coqdocvar{s}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Removing a subgraph preserves irreflexivity}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_nodes\_no\_selfloop} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{s}, \coqdocvar{no\_selfloop} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{no\_selfloop} (\coqdocvar{remove\_nodes} \coqdocvar{g} \coqdocvar{s}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Removing a node preserves undirectedness}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_node\_undirected} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{i}, \coqdocvar{undirected} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{undirected} (\coqdocvar{remove\_node} \coqdocvar{i} \coqdocvar{g}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Removing a node preserves irreflexivity}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_node\_no\_selfloop} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{i}, \coqdocvar{no\_selfloop} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{no\_selfloop} (\coqdocvar{remove\_node} \coqdocvar{i} \coqdocvar{g}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Neighborhood of a vertex}

\subsubsection{Definition of neighbors}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{neighbors} (\coqdocvar{g} : \coqdocvar{graph}) \coqdocvar{v} := \coqdocvar{adj} \coqdocvar{g} \coqdocvar{v}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Definition of neighborhood}

 The (open) neighborhood of a vertex v in a graph consists of the
    subgraph induced by the vertices adjacent to v.  It does not
    include v itself.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{neighborhood} (\coqdocvar{g} : \coqdocvar{graph}) \coqdocvar{v} := \coqdocvar{remove\_node} \coqdocvar{v} (\coqdocvar{subgraph\_of} \coqdocvar{g} (\coqdocvar{neighbors} \coqdocvar{g} \coqdocvar{v})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Neighborhoods do not include the vertex}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{nbd\_not\_include\_vertex} \coqdocvar{g} \coqdocvar{v} : \coqdocvar{M.find} \coqdocvar{v} (\coqdocvar{neighborhood} \coqdocvar{g} \coqdocvar{v}) = \coqdocvar{None}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Neighborhood is a subgraph}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{nbd\_subgraph} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{i}, \coqdocvar{is\_subgraph} (\coqdocvar{neighborhood} \coqdocvar{g} \coqdocvar{i}) \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Vertices of an induced subgraph are a subset}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subgraph\_vertices\_set} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{s}, \coqdocvar{S.Subset} (\coqdocvar{nodes} (\coqdocvar{subgraph\_of} \coqdocvar{g} \coqdocvar{s})) \coqdocvar{s}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If i is in the induced subgraph then i is in the set of inducing
    vertices.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subgraph\_of\_nodes} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{i} \coqdocvar{s}, \coqdocvar{S.In} \coqdocvar{i} (\coqdocvar{nodes} (\coqdocvar{subgraph\_of} \coqdocvar{g} \coqdocvar{s})) \ensuremath{\rightarrow} \coqdocvar{S.In} \coqdocvar{i} \coqdocvar{s}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{The adjacency set of any vertex of in an induced subgraph is a subset of the vertex set}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subgraph\_vertices\_adj} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{s} \coqdocvar{i}, \coqdocvar{S.Subset} (\coqdocvar{adj} (\coqdocvar{subgraph\_of} \coqdocvar{g} \coqdocvar{s}) \coqdocvar{i}) \coqdocvar{s}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{In neighborhood implies in adjacency set}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{nbd\_adj} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{i} \coqdocvar{j}, \coqdocvar{S.In} \coqdocvar{j} (\coqdocvar{nodes} (\coqdocvar{neighborhood} \coqdocvar{g} \coqdocvar{i})) \ensuremath{\rightarrow} \coqdocvar{S.In} \coqdocvar{j} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{i}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
When is an edge in the induced subgraph?

\begin{itemize}
\item  if \coqdocvar{i}, \coqdocvar{j} in \coqdocvar{S} and (\coqdocvar{i},\coqdocvar{j}) in \coqdocvar{G} then (\coqdocvar{i},\coqdocvar{j}) in $G|_S$

\item  if (\coqdocvar{i},\coqdocvar{j}) in $G|_S$ then (\coqdocvar{i},\coqdocvar{j}) in \coqdocvar{G}

\item  if \coqdocvar{v} in $G|_S$ then \coqdocvar{v} in \coqdocvar{S}

\item  if \coqdocvar{v} in \coqdocvar{S} and \coqdocvar{v} in \coqdocvar{G} then \coqdocvar{v} in $G|_S$

\end{itemize}


\subsection{Degrees and maximum degrees}

 Note that this is a partial function because if the vertex is not
    in the graph and we return 0, we can't tell whether it's actually
    in the graph or not. \subsubsection{Degree of a vertex}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{degree} (\coqdocvar{v} : \coqdocvar{node}) (\coqdocvar{g} : \coqdocvar{graph}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{M.find} \coqdocvar{v} \coqdocvar{g} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{None} \ensuremath{\Rightarrow} \coqdocvar{None}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{Some} \coqdocvar{a} \ensuremath{\Rightarrow} \coqdocvar{Some} (\coqdocvar{S.cardinal} \coqdocvar{a})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Maximum degree of a graph}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{max\_deg} (\coqdocvar{g} : \coqdocvar{graph}) := \coqdocvar{list\_max} (\coqdocvar{map} (\coqdockw{fun} \coqdocvar{p} \ensuremath{\Rightarrow} \coqdocvar{S.cardinal} (\coqdocvar{snd} \coqdocvar{p})) (\coqdocvar{M.elements} \coqdocvar{g})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Inversion lemma for degree}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{degree\_gt\_0\_in} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{v} : \coqdocvar{node}) \coqdocvar{n} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{degree} \coqdocvar{v} \coqdocvar{g} = \coqdocvar{Some} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{M.In} \coqdocvar{v} \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{The maximum degree of an empty graph is 0}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_deg\_empty} : \coqdocvar{max\_deg} (@\coqdocvar{M.empty} \coqdocvar{\_}) = 0.\coqdoceol
 \coqdocemptyline
\end{coqdoccode}
\subsubsection{Maximum degree bounds the size of all the adjacency sets}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_deg\_max} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{v} \coqdocvar{e}, \coqdocvar{M.find} \coqdocvar{v} \coqdocvar{g} = \coqdocvar{Some} \coqdocvar{e} \ensuremath{\rightarrow} \coqdocvar{S.cardinal} \coqdocvar{e} \ensuremath{\le} \coqdocvar{max\_deg} \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Max degree being 0 implies non-adjacency of all vertices}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_deg\_0\_adj} (\coqdocvar{g} : \coqdocvar{graph}) \coqdocvar{i} \coqdocvar{j} : \coqdocvar{max\_deg} \coqdocvar{g} = 0 \ensuremath{\rightarrow} \ensuremath{\lnot} \coqdocvar{S.In} \coqdocvar{i} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{j}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Non-zero max degree implies non-empty graph}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_deg\_gt\_not\_empty} (\coqdocvar{g} : \coqdocvar{graph}) : \coqdocvar{max\_deg} \coqdocvar{g} > 0 \ensuremath{\rightarrow} \ensuremath{\lnot} \coqdocvar{M.Empty} \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Removing a node from a graph removes it from adjaceny sets}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_node\_find} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{i} \coqdocvar{j} : \coqdocvar{node}) (\coqdocvar{e1} : \coqdocvar{nodeset}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{i} \ensuremath{\not=} \coqdocvar{j} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{M.find} \coqdocvar{j} \coqdocvar{g} = \coqdocvar{Some} \coqdocvar{e1} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{M.find} \coqdocvar{j} (\coqdocvar{remove\_node} \coqdocvar{i} \coqdocvar{g}) = \coqdocvar{Some} (\coqdocvar{S.remove} \coqdocvar{i} \coqdocvar{e1}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Removing vertex decreases degree of neighbors}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{vertex\_removed\_nbs\_dec} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{i} \coqdocvar{j} : \coqdocvar{node}) \coqdocvar{n},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{i} \ensuremath{\not=} \coqdocvar{j} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{S.In} \coqdocvar{i} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{j}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{degree} \coqdocvar{j} \coqdocvar{g} = \coqdocvar{Some} (\coqdocvar{S} \coqdocvar{n}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{degree} \coqdocvar{j} (\coqdocvar{remove\_node} \coqdocvar{i} \coqdocvar{g}) = \coqdocvar{Some} \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{S.InL and In agree}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{inl\_in} \coqdocvar{i} \coqdocvar{l} : \coqdocvar{S.InL} \coqdocvar{i} \coqdocvar{l} \ensuremath{\leftrightarrow} \coqdocvar{In} \coqdocvar{i} \coqdocvar{l}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Subset respects list inclusion of elements}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{incl\_subset} \coqdocvar{s} \coqdocvar{s'} : \coqdocvar{S.Subset} \coqdocvar{s} \coqdocvar{s'} \ensuremath{\rightarrow} \coqdocvar{incl} (\coqdocvar{S.elements} \coqdocvar{s}) (\coqdocvar{S.elements} \coqdocvar{s'}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Extract a maximum element from a non-empty list}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{list\_max\_witness} : \coqdockw{\ensuremath{\forall}} \coqdocvar{l} \coqdocvar{n}, \coqdocvar{l} \ensuremath{\not=} [] \ensuremath{\rightarrow} \coqdocvar{list\_max} \coqdocvar{l} = \coqdocvar{n} \ensuremath{\rightarrow} \{\coqdocvar{x} \ensuremath{|} \coqdocvar{In} \coqdocvar{x} \coqdocvar{l} \ensuremath{\land} \coqdocvar{x} = \coqdocvar{n}\}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Extract a vertex of maximum degree in an non-empty graph}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_degree\_vert} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{n}, \ensuremath{\lnot} \coqdocvar{M.Empty} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{max\_deg} \coqdocvar{g} = \coqdocvar{n} \ensuremath{\rightarrow} \coqdoctac{\ensuremath{\exists}} \coqdocvar{v}, \coqdocvar{degree} \coqdocvar{v} \coqdocvar{g} = \coqdocvar{Some} \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Subgraph relation respects maximum degree}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_deg\_subgraph} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} \coqdocvar{g'} : \coqdocvar{graph}), \coqdocvar{is\_subgraph} \coqdocvar{g'} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{max\_deg} \coqdocvar{g'} \ensuremath{\le} \coqdocvar{max\_deg} \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Max degree remains unchanged after removal of non-adjacent max degree vertex}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_deg\_remove\_node} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{n} : \coqdocvar{nat}) (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{v} \coqdocvar{x} : \coqdocvar{node}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{max\_deg} \coqdocvar{g} = \coqdocvar{S} \coqdocvar{n} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{degree} \coqdocvar{v} \coqdocvar{g} = \coqdocvar{Some} (\coqdocvar{S} \coqdocvar{n}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{degree} \coqdocvar{x} \coqdocvar{g} = \coqdocvar{Some} (\coqdocvar{S} \coqdocvar{n}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\lnot} \coqdocvar{S.In} \coqdocvar{x} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{v}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{x} \ensuremath{\not=} \coqdocvar{v} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{max\_deg} (\coqdocvar{remove\_node} \coqdocvar{x} \coqdocvar{g}) = \coqdocvar{S} \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Vertex extraction}

\subsubsection{Definition for a given degree}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{extract\_deg\_vert} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{d} : \coqdocvar{nat}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{find} (\coqdockw{fun} \coqdocvar{p} \ensuremath{\Rightarrow} \coqdocvar{Nat.eqb} (\coqdocvar{S.cardinal} (\coqdocvar{snd} \coqdocvar{p})) \coqdocvar{d}) (\coqdocvar{M.elements} \coqdocvar{g}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{InA\_in\_iff} \{\coqdocvar{A}\} : \coqdockw{\ensuremath{\forall}} \coqdocvar{p} (\coqdocvar{l} : \coqdocvar{list} (\coqdocvar{M.key} \ensuremath{\times} \coqdocvar{A})), (\coqdocvar{InA} (@\coqdocvar{M.eq\_key\_elt} \coqdocvar{A}) \coqdocvar{p} \coqdocvar{l}) \ensuremath{\leftrightarrow} \coqdocvar{In} \coqdocvar{p} \coqdocvar{l}.\coqdoceol
 \coqdocemptyline
\end{coqdoccode}
\subsubsection{Decidability of extracting a vertex of a given degree}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_deg\_vert\_dec} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{d} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.00em}
\{\coqdocvar{v} \ensuremath{|} \coqdocvar{degree} \coqdocvar{v} \coqdocvar{g} = \coqdocvar{Some} \coqdocvar{d}\} + \ensuremath{\lnot} \coqdoctac{\ensuremath{\exists}} \coqdocvar{v}, \coqdocvar{degree} \coqdocvar{v} \coqdocvar{g} = \coqdocvar{Some} \coqdocvar{d}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Iterated extraction}

 This subsection concerns functions that extract a list of vertices
    satisfying a degree criterion and incremental removal from the
    graph.

\subsubsection{Extracting a vertex with a given degree iteratively}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Function} \coqdocvar{extract\_vertices\_deg} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{d} : \coqdocvar{nat}) \{\coqdockw{measure} \coqdocvar{M.cardinal} \coqdocvar{g}\} : \coqdocvar{list} (\coqdocvar{node} \ensuremath{\times} \coqdocvar{graph}) \ensuremath{\times} \coqdocvar{graph} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{extract\_deg\_vert\_dec} \coqdocvar{g} \coqdocvar{d} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{inl} \coqdocvar{v} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{g'} := \coqdocvar{remove\_node} (`\coqdocvar{v}) \coqdocvar{g} \coqdoctac{in}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} (\coqdocvar{l}, \coqdocvar{g'{}'}) := \coqdocvar{extract\_vertices\_deg} \coqdocvar{g'} \coqdocvar{d} \coqdoctac{in}\coqdoceol
\coqdocindent{3.00em}
((`\coqdocvar{v}, \coqdocvar{g'}) :: \coqdocvar{l}, \coqdocvar{g'{}'})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{inr} \coqdocvar{\_} \ensuremath{\Rightarrow} (\coqdocvar{nil}, \coqdocvar{g})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Functional Scheme} \coqdocvar{extract\_vertices\_deg\_ind} := \coqdockw{Induction} \coqdockw{for} \coqdocvar{extract\_vertices\_deg} \coqdockw{Sort} \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{remove\_deg\_n\_graph} \coqdocvar{g} \coqdocvar{n} := \coqdocvar{snd} (\coqdocvar{extract\_vertices\_deg} \coqdocvar{g} \coqdocvar{n}).\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{remove\_deg\_n\_trace} \coqdocvar{g} \coqdocvar{n} := \coqdocvar{fst} (\coqdocvar{extract\_vertices\_deg} \coqdocvar{g} \coqdocvar{n}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Iterative extraction exhausts vertices of that (non-zero) degree}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_deg\_exhaust} (\coqdocvar{g} : \coqdocvar{graph}) \coqdocvar{n} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} > 0 \ensuremath{\rightarrow} \ensuremath{\lnot} \coqdoctac{\ensuremath{\exists}} \coqdocvar{v}, \coqdocvar{degree} \coqdocvar{v} (\coqdocvar{remove\_deg\_n\_graph} \coqdocvar{g} \coqdocvar{n}) = \coqdocvar{Some} \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{mempty\_dec} \{\coqdocvar{A}\} (\coqdocvar{m} : \coqdocvar{M.t} \coqdocvar{A}) : \{\coqdocvar{M.Empty} \coqdocvar{m}\} + \{\~{} \coqdocvar{M.Empty} \coqdocvar{m}\}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_deg\_subgraph1} \coqdocvar{g} \coqdocvar{g'} \coqdocvar{g'{}'} \coqdocvar{n} \coqdocvar{v} \coqdocvar{l} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{extract\_vertices\_deg} \coqdocvar{g} \coqdocvar{n} = ((\coqdocvar{v}, \coqdocvar{g'}) :: \coqdocvar{l}, \coqdocvar{g'{}'}) \ensuremath{\rightarrow} \coqdocvar{is\_subgraph} \coqdocvar{g'} \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Subgraph series}

 A subgraph series is a list of subgraphs such that later elements
    are subgraphs of former elements.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{subgraph\_series} : \coqdocvar{list} \coqdocvar{graph} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{sg\_nil} : \coqdocvar{subgraph\_series} []\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{sg\_single} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g}, \coqdocvar{subgraph\_series} [\coqdocvar{g}]\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{sg\_cons} : \coqdockw{\ensuremath{\forall}} \coqdocvar{g} \coqdocvar{g'} \coqdocvar{l}, \coqdocvar{is\_subgraph} \coqdocvar{g'} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{subgraph\_series} (\coqdocvar{g'} :: \coqdocvar{l}) \ensuremath{\rightarrow} \coqdocvar{subgraph\_series} (\coqdocvar{g} :: \coqdocvar{g'} :: \coqdocvar{l}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The subgraphs created by the extraction are a subgraph series
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_deg\_series} \coqdocvar{g} \coqdocvar{n} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{subgraph\_series} (\coqdocvar{map} \coqdocvar{snd} (\coqdocvar{remove\_deg\_n\_trace} \coqdocvar{g} \coqdocvar{n})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{The final graph returned by the vertex extraction is a subgraph.}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_deg\_subgraph} (\coqdocvar{g} : \coqdocvar{graph}) \coqdocvar{n} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{is\_subgraph} (\coqdocvar{remove\_deg\_n\_graph} \coqdocvar{g} \coqdocvar{n}) \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Max degree 0 implies all vertices have degree 0}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_deg\_0\_all\_0} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdocvar{graph}) \coqdocvar{v}, \coqdocvar{max\_deg} \coqdocvar{g} = 0 \ensuremath{\rightarrow} \coqdocvar{M.In} \coqdocvar{v} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{degree} \coqdocvar{v} \coqdocvar{g} = \coqdocvar{Some} 0.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Extracting degree 0 vertices from a max degree 0 graph empties it}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_deg0\_empty} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdocvar{graph}),\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{max\_deg} \coqdocvar{g} = 0 \ensuremath{\rightarrow} \coqdocvar{M.Empty} (\coqdocvar{remove\_deg\_n\_graph} \coqdocvar{g} 0).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Extracting all max degree vertices strictly decreases max degree}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_max\_deg} (\coqdocvar{g} : \coqdocvar{graph}) :\coqdoceol
\coqdocindent{1.50em}
\coqdocvar{max\_deg} \coqdocvar{g} > 0 \ensuremath{\rightarrow} \coqdocvar{max\_deg} (\coqdocvar{remove\_deg\_n\_graph} \coqdocvar{g} (\coqdocvar{max\_deg} \coqdocvar{g})) < \coqdocvar{max\_deg} \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Subgraph respects degree of vertices}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{degree\_subgraph} (\coqdocvar{g} \coqdocvar{g'}: \coqdocvar{graph}) \coqdocvar{v} \coqdocvar{n} \coqdocvar{m} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{is\_subgraph} \coqdocvar{g} \coqdocvar{g'} \ensuremath{\rightarrow} \coqdocvar{degree} \coqdocvar{v} \coqdocvar{g} = \coqdocvar{Some} \coqdocvar{n} \ensuremath{\rightarrow} \coqdocvar{degree} \coqdocvar{v} \coqdocvar{g'} = \coqdocvar{Some} \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{n} \ensuremath{\le} \coqdocvar{m}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Degree of a node that is removed is 0}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{degree\_remove} (\coqdocvar{g} : \coqdocvar{graph}) \coqdocvar{v} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{degree} \coqdocvar{v} (\coqdocvar{remove\_node} \coqdocvar{v} \coqdocvar{g}) = \coqdocvar{None}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Maximum degree in a subgraph implies maximum degree in original}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_deg\_subgraph\_inv} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g'} \coqdocvar{g} : \coqdocvar{graph}) \coqdocvar{v},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{is\_subgraph} \coqdocvar{g'} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{degree} \coqdocvar{v} \coqdocvar{g'} = \coqdocvar{Some} (\coqdocvar{max\_deg} \coqdocvar{g}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{degree} \coqdocvar{v} \coqdocvar{g} = \coqdocvar{Some} (\coqdocvar{max\_deg} \coqdocvar{g}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Non-adjacency of max degree vertices after one step}

 If a vertex of max degree is removed from a graph then any vertex
    with max degree in the new graph cannot be adjacent to it.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_max\_deg\_adj} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{i} \coqdocvar{j} : \coqdocvar{node}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{i} \ensuremath{\not=} \coqdocvar{j} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{M.In} \coqdocvar{i} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{degree} \coqdocvar{j} \coqdocvar{g} = \coqdocvar{Some} (\coqdocvar{max\_deg} \coqdocvar{g}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{degree} \coqdocvar{j} (\coqdocvar{remove\_node} \coqdocvar{i} \coqdocvar{g}) = \coqdocvar{Some} (\coqdocvar{max\_deg} \coqdocvar{g}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\lnot} (\coqdocvar{S.In} \coqdocvar{i} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{j})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The same as above, but for non-zero degree graphs
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{remove\_max\_deg\_adj'} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{i} \coqdocvar{j} : \coqdocvar{node}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{max\_deg} \coqdocvar{g} > 0 \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{M.In} \coqdocvar{i} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{degree} \coqdocvar{j} \coqdocvar{g} = \coqdocvar{Some} (\coqdocvar{max\_deg} \coqdocvar{g}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{degree} \coqdocvar{j} (\coqdocvar{remove\_node} \coqdocvar{i} \coqdocvar{g}) = \coqdocvar{Some} (\coqdocvar{max\_deg} \coqdocvar{g}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\lnot} (\coqdocvar{S.In} \coqdocvar{i} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{j})).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{not\_adj\_remove} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{n} \coqdocvar{m} \coqdocvar{p} : \coqdocvar{node}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{n} \ensuremath{\not=} \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{m} \ensuremath{\not=} \coqdocvar{p} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\lnot} (\coqdocvar{S.In} \coqdocvar{n} (\coqdocvar{adj} (\coqdocvar{remove\_node} \coqdocvar{m} \coqdocvar{g}) \coqdocvar{p})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\lnot} (\coqdocvar{S.In} \coqdocvar{n} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{p})).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{not\_adj\_removes} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{n} \coqdocvar{p} : \coqdocvar{node}) \coqdocvar{s},\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\lnot} \coqdocvar{S.In} \coqdocvar{n} \coqdocvar{s} \ensuremath{\rightarrow} \ensuremath{\lnot} \coqdocvar{S.In} \coqdocvar{p} \coqdocvar{s} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\lnot} (\coqdocvar{S.In} \coqdocvar{n} (\coqdocvar{adj} (\coqdocvar{remove\_nodes} \coqdocvar{g} \coqdocvar{s}) \coqdocvar{p})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\lnot} (\coqdocvar{S.In} \coqdocvar{n} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{p})).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Independent sets}

 An independent set is a set of vertices such that no two are adjacent.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{independent\_set} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{s} : \coqdocvar{nodeset}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{i} \coqdocvar{j}, \coqdocvar{S.In} \coqdocvar{i} \coqdocvar{s} \ensuremath{\rightarrow} \coqdocvar{S.In} \coqdocvar{j} \coqdocvar{s} \ensuremath{\rightarrow} \ensuremath{\lnot} \coqdocvar{S.In} \coqdocvar{i} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{j}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{independent\_set\_add} \coqdocvar{g} \coqdocvar{s} \coqdocvar{i} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{no\_selfloop} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{undirected} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{j}, \coqdocvar{S.In} \coqdocvar{j} \coqdocvar{s} \ensuremath{\rightarrow} \ensuremath{\lnot} \coqdocvar{S.In} \coqdocvar{i} (\coqdocvar{adj} \coqdocvar{g} \coqdocvar{j})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{independent\_set} \coqdocvar{g} \coqdocvar{s} \ensuremath{\rightarrow} \coqdocvar{independent\_set} \coqdocvar{g} (\coqdocvar{S.add} \coqdocvar{i} \coqdocvar{s}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{independent\_set\_subgraph} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} \coqdocvar{g'} : \coqdocvar{graph}) (\coqdocvar{s} : \coqdocvar{nodeset}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{is\_subgraph} \coqdocvar{g'} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{independent\_set} \coqdocvar{g} \coqdocvar{s} \ensuremath{\rightarrow} \coqdocvar{independent\_set} \coqdocvar{g'} \coqdocvar{s}.\coqdoceol
 \coqdocemptyline
\coqdocnoindent
\coqdockw{Function} \coqdocvar{extract\_vertices\_degs} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{d} : \coqdocvar{nat}) \{\coqdockw{measure} \coqdocvar{M.cardinal} \coqdocvar{g}\} : \coqdocvar{nodeset} \ensuremath{\times} \coqdocvar{graph} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{extract\_deg\_vert\_dec} \coqdocvar{g} \coqdocvar{d} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{inl} \coqdocvar{v} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{g'} := \coqdocvar{remove\_node} (`\coqdocvar{v}) \coqdocvar{g} \coqdoctac{in}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} (\coqdocvar{s}, \coqdocvar{g'{}'}) := \coqdocvar{extract\_vertices\_degs} \coqdocvar{g'} \coqdocvar{d} \coqdoctac{in}\coqdoceol
\coqdocindent{3.00em}
(\coqdocvar{S.add} (`\coqdocvar{v}) \coqdocvar{s} , \coqdocvar{g'{}'})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{inr} \coqdocvar{\_} \ensuremath{\Rightarrow} (\coqdocvar{S.empty}, \coqdocvar{g})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Functional Scheme} \coqdocvar{extract\_vertices\_degs\_ind} := \coqdockw{Induction} \coqdockw{for} \coqdocvar{extract\_vertices\_degs} \coqdockw{Sort} \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Extracting max degree vertices from a strictly lower max degree subgraph is empty}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_degs\_empty} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{g} \coqdocvar{g'} \coqdocvar{g'{}'} : \coqdocvar{graph}) (\coqdocvar{d} : \coqdocvar{nat}) (\coqdocvar{v} : \coqdocvar{node}) \coqdocvar{s},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{is\_subgraph} \coqdocvar{g'} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{d} = \coqdocvar{max\_deg} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{extract\_vertices\_degs} \coqdocvar{g'} \coqdocvar{d} = (\coqdocvar{s}, \coqdocvar{g'{}'}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{max\_deg} \coqdocvar{g'} < \coqdocvar{max\_deg} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{degree} \coqdocvar{v} \coqdocvar{g} = \coqdocvar{Some} \coqdocvar{d} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{S.Empty} \coqdocvar{s}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_degree\_extraction\_independent\_set0} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdocvar{graph}) \coqdocvar{d},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{no\_selfloop} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{d} = \coqdocvar{max\_deg} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{d} = 0 \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{independent\_set} \coqdocvar{g} (\coqdocvar{fst} (\coqdocvar{extract\_vertices\_degs} \coqdocvar{g} \coqdocvar{d})) \ensuremath{\land}\coqdoceol
\coqdocindent{3.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{k}, \coqdocvar{S.In} \coqdocvar{k} (\coqdocvar{fst} (\coqdocvar{extract\_vertices\_degs} \coqdocvar{g} \coqdocvar{d})) \ensuremath{\rightarrow} \coqdocvar{degree} \coqdocvar{k} \coqdocvar{g} = \coqdocvar{Some} \coqdocvar{d}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Extracting max degree vertices gives an independent set}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_degree\_extraction\_independent\_set} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdocvar{graph}) (\coqdocvar{d} : \coqdocvar{nat}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{undirected} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{no\_selfloop} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{d} = \coqdocvar{max\_deg} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{independent\_set} \coqdocvar{g} (\coqdocvar{fst} (\coqdocvar{extract\_vertices\_degs} \coqdocvar{g} \coqdocvar{d})) \ensuremath{\land}\coqdoceol
\coqdocindent{3.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{k}, \coqdocvar{S.In} \coqdocvar{k} (\coqdocvar{fst} (\coqdocvar{extract\_vertices\_degs} \coqdocvar{g} \coqdocvar{d})) \ensuremath{\rightarrow} \coqdocvar{degree} \coqdocvar{k} \coqdocvar{g} = \coqdocvar{Some} \coqdocvar{d}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Iterative extraction exhausts vertices of that (non-zero) degree}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_degs\_exhaust} (\coqdocvar{g} \coqdocvar{g'} : \coqdocvar{graph}) \coqdocvar{n} \coqdocvar{ns} :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{n} > 0 \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{extract\_vertices\_degs} \coqdocvar{g} \coqdocvar{n} = (\coqdocvar{ns}, \coqdocvar{g'}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\lnot} \coqdoctac{\ensuremath{\exists}} \coqdocvar{v}, \coqdocvar{degree} \coqdocvar{v} \coqdocvar{g'} = \coqdocvar{Some} \coqdocvar{n}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Iterative extraction results in a subgraph}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_degs\_subgraph} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} \coqdocvar{g'} : \coqdocvar{graph}) \coqdocvar{n} \coqdocvar{ns},\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{extract\_vertices\_degs} \coqdocvar{g} \coqdocvar{n} = (\coqdocvar{ns}, \coqdocvar{g'}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{is\_subgraph} \coqdocvar{g'} \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Iterative extraction preserves undirectedness}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_degs\_undirected} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} \coqdocvar{g'} : \coqdocvar{graph}) \coqdocvar{n} \coqdocvar{ns},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{undirected} \coqdocvar{g} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{extract\_vertices\_degs} \coqdocvar{g} \coqdocvar{n} = (\coqdocvar{ns}, \coqdocvar{g'}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{undirected} \coqdocvar{g'}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Iterative max degree extraction strictly decreases the max degree}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_max\_degs} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} \coqdocvar{g'} : \coqdocvar{graph}) \coqdocvar{ns},\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{max\_deg} \coqdocvar{g} > 0 \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{extract\_vertices\_degs} \coqdocvar{g} (\coqdocvar{max\_deg} \coqdocvar{g}) = (\coqdocvar{ns}, \coqdocvar{g'}) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{max\_deg} \coqdocvar{g'} < \coqdocvar{max\_deg} \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Vertices in extraction are not in resulting graph but are in original graph}

 Later we can use this to show that the vertices after each round
    of extraction are disjoint.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{extract\_vertices\_remove} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} \coqdocvar{g'} : \coqdocvar{graph}) \coqdocvar{s} \coqdocvar{n},\coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{s}, \coqdocvar{g'}) = \coqdocvar{extract\_vertices\_degs} \coqdocvar{g} \coqdocvar{n} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{v}, \coqdocvar{S.In} \coqdocvar{v} \coqdocvar{s} \ensuremath{\rightarrow} \ensuremath{\lnot} \coqdocvar{M.In} \coqdocvar{v} \coqdocvar{g'} \ensuremath{\land} \coqdocvar{M.In} \coqdocvar{v} \coqdocvar{g}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsubsection{Disjointness of after each round of extraction}


\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{max\_degree\_extraction\_disjoint} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{g} \coqdocvar{g'} \coqdocvar{g'{}'} : \coqdocvar{graph}) (\coqdocvar{n} \coqdocvar{m} : \coqdocvar{nat}) \coqdocvar{s} \coqdocvar{s'},\coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{s}, \coqdocvar{g'}) = \coqdocvar{extract\_vertices\_degs} \coqdocvar{g} \coqdocvar{n} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{s'}, \coqdocvar{g'{}'}) = \coqdocvar{extract\_vertices\_degs} \coqdocvar{g'} \coqdocvar{m} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{S.Empty} (\coqdocvar{S.inter} \coqdocvar{s} \coqdocvar{s'}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}


\newpage
\printbibliography[heading=bibintoc]
